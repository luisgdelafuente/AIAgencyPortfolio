Ensure content.features is an Array
You need to make sure that content.features is always an array, even if the data is not available or is malformed.

Solution 1: Default Fallback
You can provide a default empty array using JavaScript's logical OR (||) or by using a more robust fallback approach. This will ensure that even if content.features is undefined or null, you will always get an array to call .map() on.

Modify your code like this:

tsx
Copiar
Editar
<div className="grid grid-cols-1 md:grid-cols-3 gap-8">
  {(content.features || []).map((feature, index) => (
    <FeatureCard
      key={index}
      icon={featureIcons[index % featureIcons.length]}
      {...feature} // assuming you're passing the feature props here
    />
  ))}
</div>
This checks if content.features is truthy, and if not, it defaults to an empty array []. As a result, .map() will not throw an error, even if content.features is undefined or null.

Solution 2: Additional Conditional Rendering
If content.features can sometimes be a non-array value (e.g., an object or another type), you can also add a more specific check for the array before calling .map():

tsx
Copiar
Editar
<div className="grid grid-cols-1 md:grid-cols-3 gap-8">
  {Array.isArray(content.features) && content.features.length > 0 ? (
    content.features.map((feature, index) => (
      <FeatureCard
        key={index}
        icon={featureIcons[index % featureIcons.length]}
        {...feature}
      />
    ))
  ) : (
    <p>No features available.</p> // or another fallback UI
  )}
</div>
Here, Array.isArray(content.features) ensures that content.features is an actual array before calling .map(). If it's not an array, the fallback message ("No features available.") is rendered instead.

2. Check the Data Source
If this data (content.features) is being fetched or dynamically loaded, it's a good idea to inspect the data structure you're receiving and ensure that it always returns an array (even if empty) from your API or data source. This way, you can avoid these types of issues.

For example, if you're fetching the content object from an API, check that the response always provides features as an array:

ts
Copiar
Editar
const content = await fetchData();
const features = Array.isArray(content.features) ? content.features : []; // Fallback to an empty array
3. Debugging
If you're unsure of the exact type of content.features, you can log it to the console to inspect its value:

tsx
Copiar
Editar
console.log(content.features);
This will help you understand the data structure and pinpoint why itâ€™s not an array.

Conclusion
The issue is that content.features is not always an array. To fix this, either provide a fallback to an empty array with || [], or perform a more explicit check with Array.isArray() before calling .map(). This will prevent runtime errors when content.features is not what you expect it to be.

Let me know if you need further assistance!